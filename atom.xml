<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonH&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasonhj.github.io/"/>
  <updated>2017-04-25T14:14:03.562Z</updated>
  <id>https://jasonhj.github.io/</id>
  
  <author>
    <name>Jason He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解析this的四种绑定规则</title>
    <link href="https://jasonhj.github.io/2017/04/25/%E8%A7%A3%E6%9E%90this%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99/"/>
    <id>https://jasonhj.github.io/2017/04/25/解析this的四种绑定规则/</id>
    <published>2017-04-25T13:50:36.000Z</published>
    <updated>2017-04-25T14:14:03.562Z</updated>
    
    <content type="html"><![CDATA[<p>导语：</p>
<blockquote>
<p>本文主要归纳总结自《你不知道的JavaScript上卷》中的关于this的解析。</p>
</blockquote>
<p>关于this</p>
<ul>
<li>this既不指向函数自身也不止像函数的词法作用域；</li>
<li>this是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</li>
<li>this的绑定和函数声明的位置没有任何关系，只取决于函数的调用。</li>
</ul>
<a id="more"></a>
<p>##this的四种绑定规则</p>
<p>1.默认绑定</p>
<p><pre><code><br>function foo(){<br>  console.log(this.a);<br>}<br>var a=2;<br>foo(); // 输出2，原因：foo在全局作用域里被调用，所以this绑定的是全局作用域。<br></code></pre></p>
<p><pre><code><br>function foo(){<br>  “use strict”<br>   console.log(this.a);<br>}<br>var a=2;<br>foo();// TypeError:this is undefined<br></code></pre><br>若使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined。</p>
<p><pre><code><br>function foo(){<br>    console.log(this.a);<br>}<br>var a=2;<br>(function(){<br>   “use strict”<br>   foo();//输出2<br>})();<br>在严格模式下调用foo()则不影响默认绑定。<br></code></pre></p>
<p>2.隐式绑定<br>考虑：调用位置是否有上下文对象，或者是否被某个对象拥有或包含。<br>    1–&gt;function foo(){<br>            console.log(this.a);<br>        }<br>        var obj={<br>            a:2,<br>            foo:foo<br>        }<br>        obj.foo();// 输出2 原因:foo()再被调用的时候，前面加上了对obj的引用，当函数引用有上下文对象时，函数中的this会绑定上去。<br>        var obj1={<br>            a:42;<br>            obj:obj<br>        }<br>        obj1.obj.foo();//输出2 原因：对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。</p>
<pre><code>2--&gt;隐式丢失
    function foo(){
        console.log(this.a);
    }
    var obj={
        a:2,
        foo:foo
    }
    var bar=obj.foo;
    var a=&quot;oops,global&quot;;
    bar(); //输出oops,global
    原因：虽然bar是obj.foo的一个引用，但实际它引用的是foo函数本身，因此bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。

    回调函数丢失this绑定
    function foo(){
        console.log(this.a);
    }
    function doFoo(fn){
        //fn其实引用的是foo
        fn();
    }
    var obj={
        a:2,
        foo:foo
    };
    var a=&quot;oops,global&quot;;
    doFoo(obj.foo);  //输出&quot;oops,global&quot; 相当于fn=obj.foo;fn();
    参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。

    作为参数传入内置函数，也会发生隐式丢失
    function foo(){
        console.log(this.a);
    }
    var obj={
        a:2,
        foo:foo
    };
    var a=&quot;oops,global&quot;;
    setTimeout(obj.foo,100);////输出&quot;oops,global&quot;
</code></pre><p>3.显示绑定<br>使用call(..)和apply(..)，他们的第一个参数是一个对象，在调用函数时将其绑定到this。<br>    1–&gt;function foo(){<br>            console.log(this.a);<br>        }<br>        var obj={<br>            a:2<br>        }<br>        foo.call(obj);//输出2<br>        如果你传入一个原始值(字符串类型、布尔类型)来当做this的绑定对象，这个原始值会被转换成他的对象形式。称为“装箱”。<br>        问题：显示绑定无法解决我们之前的丢失绑定问题？但显示绑定的变种——硬绑定可以解决。</p>
<pre><code>2--&gt;硬绑定
    function foo(){
        console.log(this.a);
    }
    var obj={
        a:2
    };
    var bar=function(){
        foo.call(obj);
    }
    bar();//输出2
    setTimeout(bar,100);//输出2
    //硬绑定的bar不可能再修改它的this
    bar.call(window);//输出2
    硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值；

3--&gt;bind
    由于硬绑定是一种非常常用的模式，所以ES5提供了内置的方法Function.prototype.bind:
    function foo(something){
        console.log(this.a,something);
        return this.a+something;
    }
    var obj={
        a:2
    };
    var b=bar(3);
    console.log(b);
</code></pre><p>4.new绑定<br>        function foo(a){<br>            this.a=a;<br>        }<br>        var bar=new foo(2);<br>        console.log(bar.a);//输出2<br>        使用new来调用foo(…)时，我们会构造一个新对象并把它绑定到foo(…)调用中的this上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导语：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要归纳总结自《你不知道的JavaScript上卷》中的关于this的解析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this既不指向函数自身也不止像函数的词法作用域；&lt;/li&gt;
&lt;li&gt;this是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。&lt;/li&gt;
&lt;li&gt;this的绑定和函数声明的位置没有任何关系，只取决于函数的调用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node.js深入浅出</title>
    <link href="https://jasonhj.github.io/2017/04/25/node-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"/>
    <id>https://jasonhj.github.io/2017/04/25/node-js深入浅出/</id>
    <published>2017-04-25T13:27:49.000Z</published>
    <updated>2017-04-25T14:16:08.731Z</updated>
    
    <content type="html"><![CDATA[<p>导语：</p>
<blockquote>
<p>从本篇文章开始，将对《node.js深入浅出》这本书进行学习，并总结出每一章的知识点概要，如果有时间也会整理出一份详细的思维导图出来，有兴趣的朋友可以一起学习讨论。</p>
</blockquote>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导语：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从本篇文章开始，将对《node.js深入浅出》这本书进行学习，并总结出每一章的知识点概要，如果有时间也会整理出一份详细的思维导图出来，有兴趣的朋友可以一起学习讨论。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的博客</title>
    <link href="https://jasonhj.github.io/2017/04/23/hello/"/>
    <id>https://jasonhj.github.io/2017/04/23/hello/</id>
    <published>2017-04-23T14:31:37.000Z</published>
    <updated>2017-04-24T15:22:38.958Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="全新的主题---NEXT" scheme="https://jasonhj.github.io/tags/%E5%85%A8%E6%96%B0%E7%9A%84%E4%B8%BB%E9%A2%98-NEXT/"/>
    
  </entry>
  
</feed>
